\documentclass[12pt]{article}
\usepackage[margin=0.75in]{geometry}
\usepackage{amsmath}
\usepackage{graphicx}

\begin{document}

\begin{titlepage}
\vfill
\begin{center}
\textbf{\Large Cloud Server Cost Optimization for a Web Application}

\vspace{0.5cm}

\textbf{Group Members:} Sarthak Sethi, Mohit Patil

\vspace{0.3cm}

\textbf{Course:} MATH 177, Fall 2025, Mohammad Yahdi

\vspace{0.3cm}

\textbf{Date: }\today
\end{center}
\vfill

\end{titlepage}

\section{Introduction and Motivation}

\subsection{Context}

Cloud computing providers such as AWS, GCP, Azure, IBM Cloud, etc., offer various virtual machine instance types with different CPU and RAM configurations. Companies can scale their infrastructure based on demand, but web application traffic varies throughout the day. Peak periods require more computational resources than off-peak hours.

\subsection{Problem}

Companies must decide how many instances of each type to provision during different demand periods to optimize cloud infrastructure costs. Overprovisioning resources wastes money by paying for unused capacity. Underprovisioning leads to poor performance, increased latency, and potential service outages that harm user experience and reliability.

\subsection{Goal}

The goal of this project is to build a linear programming model that chooses the cheapest combination of cloud server types for different traffic periods while meeting CPU and RAM requirements.

\subsection{Approach}

This project defines a linear programming model that minimizes total cost subject to CPU and RAM constraints across multiple time periods. The model is implemented in Python using PuLP and solved with an LP solver. The solution is tested under scenarios including demand increases and price changes to demonstrate cost optimization effectiveness.

\section{Problem Setup and Data}


The day is divided into three traffic periods: \textbf{Off Peak}, \textbf{Normal}, and \textbf{Peak}. These represent low-traffic, moderate-traffic, and high-traffic hours respectively.

\vspace{0.5cm}

\noindent The cloud provider offers three instance types: \textbf{Small}, \textbf{Medium}, and \textbf{Large}. Each type has a cost per hour, CPU capacity, and RAM capacity. Larger instances provide more CPU and RAM at higher cost.

\begin{table}[h]
\centering
\caption{Instance Parameters}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Instance Type} & \textbf{Cost per Hour (\$)} & \textbf{CPU Capacity} & \textbf{RAM Capacity (GB)} \\
\hline
Small & 0.06 & 1 & 2 \\
\hline
Medium & 0.10 & 2 & 4 \\
\hline
Large & 0.18 & 4 & 8 \\
\hline
\end{tabular}
\end{table}

\begin{table}[h]
\centering
\caption{Resource Demand per Period}
\begin{tabular}{|l|c|c|}
\hline
\textbf{Period} & \textbf{CPU Demand} & \textbf{RAM Demand (GB)} \\
\hline
Off Peak & 6 & 12 \\
\hline
Normal & 10 & 20 \\
\hline
Peak & 18 & 36 \\
\hline
\end{tabular}
\end{table}

\vspace{5cm}

\noindent As shown in Table 2, resource demand varies across periods, with Peak requiring more CPU and RAM than Off Peak. Normal represents an intermediate level. RAM demand is proportional to CPU demand across all periods.

\section{Mathematical Model}

\subsection{Sets}

The model uses the following sets:

\begin{align*}
T &= \{\text{Off Peak}, \text{Normal}, \text{Peak}\} \\
K &= \{\text{Small}, \text{Medium}, \text{Large}\}
\end{align*}

\noindent where $T$ represents the set of time periods and $K$ represents the set of available instance types.

\subsection{Parameters}

The following parameters define the problem data:

\begin{itemize}
    \item $c_k$: cost per hour of one instance of type $k$ (\$)
    \item $\text{cpu}_k$: CPU capacity of one instance of type $k$ (CPU units)
    \item $\text{ram}_k$: RAM capacity of one instance of type $k$ (gigabytes)
    \item $D_t^{\text{cpu}}$: CPU demand in period $t$ (CPU units)
    \item $D_t^{\text{ram}}$: RAM demand in period $t$ (gigabytes)
\end{itemize}

\subsection{Decision Variables}

The decision variable is:

\begin{itemize}
    \item $x_{t,k}$: number of instances of type $k$ running in period $t$
\end{itemize}

\noindent where $x_{t,k} \geq 0$ and integer for all $t \in T$ and $k \in K$.

\subsection{Objective Function}

The objective is to minimize the total hourly cloud cost:

\begin{equation}
\min \sum_{t \in T} \sum_{k \in K} c_k x_{t,k}
\end{equation}

\noindent This minimizes the total hourly cost across all periods and instance types.

\subsection{Constraints}

The model includes the following constraints:
\vspace{0.2cm}

\textbf{(a) CPU constraints for each period:}
\begin{equation}
\sum_{k \in K} \text{cpu}_k x_{t,k} \geq D_t^{\text{cpu}} \quad \forall t \in T
\end{equation}

\textbf{(b) RAM constraints for each period:}
\begin{equation}
\sum_{k \in K} \text{ram}_k x_{t,k} \geq D_t^{\text{ram}} \quad \forall t \in T
\end{equation}

\textbf{(c) Redundancy constraint:}
\begin{equation}
\sum_{k \in K} x_{t,k} \geq 2 \quad \forall t \in T
\end{equation}

\subsection{Constraint Interpretation}

The CPU constraint (a) ensures total CPU capacity meets or exceeds demand in each period. The RAM constraint (b) ensures total RAM capacity meets or exceeds demand in each period. The redundancy constraint (c) requires at least two instances per period for fault tolerance.

\section{Tools and Implementation}

\subsection{Tools Used}

The implementation uses Python 3 with PuLP for linear programming, pandas for data tables, and matplotlib for bar charts. PuLP formulates and solves the LP problem, pandas organizes and displays data, and matplotlib creates visualizations of instance allocations.

\subsection{High-Level Modeling Steps}

The implementation follows a systematic approach to solve the cloud server cost optimization problem:

\vspace{0.4cm}

\noindent \textbf{Step 1:} Define lists of periods and instance types in Python to represent the sets $T$ and $K$ from the mathematical model.

\vspace{0.2cm}

\noindent \textbf{Step 2:} Store costs, CPU capacities, RAM capacities, and demand values in dictionaries keyed by instance type or period, corresponding to the parameters $c_k$, $\text{cpu}_k$, $\text{ram}_k$, $D_t^{\text{cpu}}$, and $D_t^{\text{ram}}$.

\vspace{0.2cm}

\noindent \textbf{Step 3:} Create an LP minimization problem using PuLP's problem constructor, which initializes the optimization framework.

\vspace{0.2cm}

\noindent \textbf{Step 4:} Define integer decision variables $x_{t,k}$ for each combination of period $t$ and instance type $k$, representing the number of instances of each type to run in each period.

\vspace{0.2cm}

\noindent \textbf{Step 5:} Add the objective function from Section 3, which minimizes the sum of costs across all periods and instance types: $\min \sum_{t \in T} \sum_{k \in K} c_k x_{t,k}$.

\vspace{0.2cm}

\noindent \textbf{Step 6:} Add CPU and RAM constraints per period, ensuring that the total capacity provided by all instances meets or exceeds the demand for each resource in each period.

\vspace{0.2cm}

\noindent \textbf{Step 7:} Call the LP solver through PuLP and retrieve the optimal values of $x_{t,k}$, which represent the cost-minimizing allocation of instances.

\vspace{0.2cm}

\noindent \textbf{Step 8:} Use Pandas to create tables of the optimal allocation showing how many instances of each type are used in each period, along with the total cost of the solution.

\vspace{0.2cm}

\noindent \textbf{Step 9:} Use Matplotlib to create a bar chart visualizing the number of instances per period, providing an intuitive representation of how resource allocation varies across different demand periods.

\subsection{Link to Course Tools}

This implementation uses linear programming and the simplex method indirectly, as PuLP employs an LP solver that utilizes algorithms similar to the simplex method discussed in class to find the optimal solution to the formulated problem.

\section{Results}

\subsection{Solution Table}

Table 3 shows the optimal allocation of instances across all periods, including instance counts and period costs. The solution was obtained by solving the linear programming model from Section 3.

\begin{table}[h]
\centering
\caption{Optimal Instance Allocation and Costs}
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Period} & \textbf{Small} & \textbf{Medium} & \textbf{Large} & \textbf{Period Cost (\$)} \\
\hline
Off Peak & 0 & 1 & 1 & 0.28 \\
\hline
Normal & 0 & 1 & 2 & 0.46 \\
\hline
Peak & 0 & 1 & 4 & 0.82 \\
\hline
\multicolumn{4}{|r|}{\textbf{Total hourly cost:}} & 1.56 \\
\hline
\end{tabular}
\end{table}

\subsection{Interpretation of the Solution}

The optimal solution shows that large instances dominate across all periods (1 in Off Peak, 2 in Normal, 4 in Peak), Medium instances appear consistently (1 in each period), and Small instances are never used. This reflects cost efficiency: Large instances have the lowest cost per unit (\$0.045 per CPU, \$0.0225 per GB RAM), followed by Medium (\$0.05 per CPU, \$0.025 per GB), and Small (\$0.06 per CPU, \$0.03 per GB).

\vspace{0.3cm}

\noindent Both CPU and RAM constraints are binding in all periods, meaning capacity exactly meets demand with no excess. The model prefers Large instances due to economies of scale, making them more cost-effective for these demand levels. The solution minimizes total hourly cost (\$1.56) while scaling appropriately with demand.

\subsection{Visualization}

Figure 1 shows a bar chart of the optimal instance allocation across periods, illustrating how allocation scales with demand.

\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{instance_allocation.png}
\caption{Optimal number of Small, Medium, and Large instances in each traffic period.}
\end{figure}

\subsection{Constraint Verification}

The optimal solution was verified to ensure all constraints are satisfied. For each period, total CPU capacity (sum of $\text{cpu}_k \times x_{t,k}$) meets or exceeds CPU demand $D_t^{\text{cpu}}$, and total RAM capacity (sum of $\text{ram}_k \times x_{t,k}$) meets or exceeds RAM demand $D_t^{\text{ram}}$. The redundancy constraint is satisfied with at least two instances per period. All constraints are satisfied, confirming feasibility and correctness.

\section{Scenario Analysis and Recommendations}

\subsection{Scenario Descriptions}

To understand the sensitivity of the optimal solution to changes in demand and pricing, two additional scenarios were analyzed:

\vspace{0.3cm}

\noindent \textbf{Scenario A: Peak Demand Increase}

\noindent Peak period CPU and RAM demand increased by 20 percent compared to the base case, simulating significant traffic growth. Off Peak and Normal periods remained unchanged. In Python, Peak demand parameters ($D_{\text{Peak}}^{\text{cpu}}$ and $D_{\text{Peak}}^{\text{ram}}$) were multiplied by 1.2.

\vspace{0.3cm}

\noindent \textbf{Scenario B: Large Instance Price Increase}

\noindent Large instance cost increased by 15 percent compared to the base case, simulating pricing adjustments or market changes. All other parameters remained unchanged. In Python, the cost parameter $c_{\text{Large}}$ was multiplied by 1.15.

\subsection{Scenario Summary}

Table 4 compares the total cost and high-level allocation patterns across the base case and the two scenarios.

\begin{table}[h]
\centering
\caption{Scenario Comparison}
\begin{tabular}{|l|c|l|}
\hline
\textbf{Scenario} & \textbf{Total Cost (\$)} & \textbf{High-Level Allocation Notes} \\
\hline
Base & 1.56 & Large dominates, Medium appears in all periods \\
\hline
Peak +20\% & 1.74 & More Large instances used in Peak (5 Large vs 4) \\
\hline
Large +15\% & 1.70 & No Large instances used, all Medium instances \\
\hline
\end{tabular}
\end{table}

\subsection{Interpretation and Recommendations}


When Peak demand increases by 20 percent, total cost increases from \$1.56 to \$1.74 (11.5\% increase), which is less than proportional to the demand increase. The model responds by allocating more Large instances in Peak (5 instead of 4) while maintaining one Medium instance.

\vspace{0.3cm}

\noindent When Large instance cost increases by 15 percent, total cost increases to \$1.70, but the model shifts completely away from Large instances, using only Medium instances across all periods. This shows the model adapts to price changes by rebalancing the instance mix to maintain cost minimization.

\vspace{0.3cm}

\noindent \textbf{Recommendations:} Companies should expect costs to rise with demand increases, though not necessarily proportionally. If Large instances become more expensive, the model shifts to Medium instances, demonstrating the importance of regularly re-optimizing resource allocation as pricing evolves. Monitor both demand patterns and instance pricing to maintain cost-optimal configurations.



\section{Conclusion}

This project optimized cloud server costs for a web application with varying demand across time periods. The linear programming model determined the cost-minimizing combination of instance types (Small, Medium, Large) that meets CPU and RAM requirements while avoiding overprovisioning and underprovisioning.

\vspace{0.3cm}

\noindent The model successfully identified optimal allocations minimizing total hourly cost (\$1.56) while satisfying all constraints. The optimal solution showed Large instances dominate (increasing from 1 to 4 across periods), Medium instances appear consistently (1 in each period), and Small instances are never used due to cost inefficiency. Under scenario variations, the model adapts effectively: Peak demand increases raise costs to \$1.74 with more Large instances, while Large price increases shift allocation to all Medium instances at \$1.70.

\vspace{0.3cm}

\noindent Linear programming provides an effective framework for cloud cost optimization, enabling data-driven resource allocation decisions. The model adapts to changing conditions while maintaining cost efficiency. Possible extensions include latency constraints, multiple cloud regions, spot instances, and maximum instance count limits.

\end{document}

